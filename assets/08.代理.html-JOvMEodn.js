import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as o,b as e,d as a}from"./app-4WSKpjB8.js";const r={},c=e("h3",{id:"静态代理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#静态代理","aria-hidden":"true"},"#"),a(" 静态代理")],-1),s=e("p",null,"静态代理是在编译时就已经确定代理类的结构，需要手动编写代理类。 代理类和被代理类实现相同的接口或继承相同的父类， 代理类中包含对被代理对象的引用， 通过调用被代理对象的方法来间接实现目标操作。 静态代理的缺点是每个被代理对象都需要编写一个代理类，代码重复且不灵活。",-1),_=e("h3",{id:"动态代理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#动态代理","aria-hidden":"true"},"#"),a(" 动态代理")],-1),d=e("p",null,"动态代理是在运行时动态生成代理类，不需要手动编写代理类。 Java 中的动态代理主要依靠 java.lang.reflect.Proxy 类 和 java.lang.reflect.InvocationHandler 接口实现。 通过 Proxy.newProxyInstance() 方法创建代理对象， 并传入一个实现了 InvocationHandler 接口的处理器对象， 处理器对象负责在代理对象上调用方法时执行额外的操作。",-1),i=[c,s,_,d];function l(h,f){return n(),o("div",null,i)}const m=t(r,[["render",l],["__file","08.代理.html.vue"]]);export{m as default};
