import{_ as r}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as t,c as n,a as e}from"./app-M9P2o3O-.js";const i={},a=e('<p>字符串: String 、StringBuffer 、StringBuilder</p><h3 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h3><p><strong>String</strong> 类是不可变的，一旦创建就不能被修改。每次对 String 进行操作（连接、拼接、修改等），都会创建一个新的 String 对象。</p><p><strong>String</strong> 对象在 Java 字符串常量池中，因此具有相同内容的 String 对象可能会共享相同的内存。</p><p>由于 String 对象的不可变性，适用于在不需要修改字符串的情况下进行字符串操作，例如常量字符串、字符串比较等。</p><h3 id="stringbuffer" tabindex="-1"><a class="header-anchor" href="#stringbuffer" aria-hidden="true">#</a> StringBuffer</h3><p><strong>StringBuffer</strong> 是可变的，可以通过 append()、insert()、delete()、replace() 等方法来修改字符串内容，而不会创建新的对象。</p><p><strong>StringBuffer</strong> 是线程安全的，所有的方法都是同步的（即使用了 synchronized 关键字）。</p><h3 id="stringbuilder" tabindex="-1"><a class="header-anchor" href="#stringbuilder" aria-hidden="true">#</a> StringBuilder</h3><p><strong>StringBuilder</strong> 与 StringBuffer 类似，也是可变的，可以进行字符串的修改操作，但是它不是线程安全的。</p><p><strong>StringBuilder</strong> 的方法不是同步的，因此在单线程环境下性能更好，一般推荐在单线程环境下使用。</p><p><strong>StringBuilder</strong> 在 Java 5 中引入，相比 StringBuffer，其性能更好。</p>',12),s=[a];function g(o,d){return t(),n("div",null,s)}const c=r(i,[["render",g],["__file","03.字符串_API.html.vue"]]);export{c as default};
